- 버블 정렬은 N개의 원소가 있을 때 첫번째 원소를 기준으로 N개의 원소와 비교해주면서
- 비교하는 원소보다 첫번째 원소가 큰 경우 두 원소의 위치를 바꾸어 주면서 첫번째 원소의 위치를 찾아준다
- 그 다음 두번째, 세번째 .. N-1개의 원소를 각각 기준으로 정렬해주면서 원소의 위치를 찾아주는 정렬이다 

- 비교 횟수
    - 버블 정렬의 경우 제일 첫번째 원소를 기준으로 N-1번의 비교
    - 두번째 원소 기준으로 N-2번의 비교를 하므로 
    - (N-1) + (N-2) + ... + 1
    - 따라서 최선의 경우와 최악의 경우 상관 없이 시간 복잡도는 O(n^2)가 된다 


- 교환 횟수
    - 모두 정렬되어있는 경우 최상의 경우에는 원소 간의 교환이 일어나지 않는다
    - 원소가 역순으로 정렬되어 있는 최악의 경우 교환 과정에서 대입 연산이 3번 진행되기 때문에 
    - 3 * n(n-1) /2 가 된다 


- 시간 복잡도
    - 비교 연산에 대한 시간 빅-오는 O(n^2)
    - 교환 횟수데 대한 빅-오는 최악의 경우를 기준으로 O(n^2)

- 장점
    - 구현이 쉽다
- 단점
    - 시간 복잡도가 너무 높아서 부담스러운 성능을 가진다


```

[3, 2, 4, 1] --> [2, 3, 4, 1] # 3과 2 비교 후 3과 2 교환

[2, 3, 4, 1] --> [2, 3, 4,1] # 3과 4 비교

[2, 3, 4, 1] --> [2, 3, 1, 4] # 4와 1 비교 후 4와 1 교환

# 가장 큰 수 4의 위치가 정해졌다
# 4 이전까지 다시 한번 더 비교를 해서 3의 위치를 정해준다 

```


```python
lst = [5,3,31,1,2,4,10,29,40,23,11]
```


```python
for i in range(len(lst)-1): # n개 원소 있으면 최대 비교 횟수는 n-1번, index 위치 때문에 len(lst)-1 해준다 
    for j in range((len(lst)-1)-i): # 반복할 때 마다 각 원소의 위치가 정해지기 때문에 비교횟수는 점점 더 작아진다 
        if lst[j] > lst[j+1]:
            temp = lst[j+1]
            lst[j+1] = lst[j]
            lst[j] = temp
```


```python
lst
```




    [1, 2, 3, 4, 5, 10, 11, 23, 29, 31, 40]


