```python
- 인접행렬에서 주위 인접한 곳의 값이 1인 것들을 모두 찾는 문제이다
- 따라서 BFS로 해결할 수 있다
- BFS를 한번 반복할 때 마다 단지 수를 하나 씩 찾는 것과 같다 
```

- Sample case


```
25
0101010101010101010101010
1010101010101010101010101
0101010101010101010101010
1010101010101010101010101
0101010101010101010101010
1010101010101010101010101
0101010101010101010101010
1010101010101010101010101
0101010101010101010101010
1010101010101010101010101
0101010101010101010101010
1010101010101010101010101
0101010101010101010101010
1010101010101010101010101
0101010101010101010101010
1010101010101010101010101
0101010101010101010101010
1010101010101010101010101
0101010101010101010101010
1010101010101010101010101
0101010101010101010101010
1010101010101010101010101
0101010101010101010101010
1010101010101010101010101
0101010101010101010101010

5
11011
10000
00000
10001
00001

25
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111
1111111111111111111111111


```


```python
import sys
from collections import deque


N = int(sys.stdin.readline())


graph = [list(input()) for _ in range(N)]
visited = [[False]*N for _ in range(N)]
```


```python
def bfs(graph, i, j):
    queue = deque()
    queue.append([i,j])
    count = 0 # 각 단지에 속하는 집의 수를 찾기 위한 변수 
    visited[i][j] = True
    if graph[i][j] == '1': # 1로 시작하는 경우 1개 카운트 해준다 
        count+=1
    
    while(queue):
        a, b= queue.popleft()
        
        if b < N-1 and visited[a][b+1] == False and graph[a][b+1] =='1': # left
            queue.append([a,b+1])
            visited[a][b+1] = True
            count +=1
            
        if b >0 and visited[a][b-1] == False and graph[a][b-1] == '1': # right
            queue.append([a,b-1])
            visited[a][b-1] = True
            count +=1
            
            
        if a >0 and visited[a-1][b] == False and graph[a-1][b] == '1': # up
            queue.append([a-1, b])
            visited[a-1][b] = True
            count +=1

        if a < N-1 and visited[a+1][b] == False and graph[a+1][b] == '1': # down
            queue.append([a+1, b])
            visited[a+1][b] = True
            count +=1
    return count
```


```python
group_count = 0
count_list = []

for i in range(N):
    for j in range(N):
        if visited[i][j] == False and graph[i][j] == '1': # 반례 1번처럼 0번에서 시작하는 것이 아니라 1번에서 시작해야 한다 
            result = bfs(graph, i, j)
            if result != 0: # 각 단지에 속하는 집의 개수가 0이 아닌 경우에만
                group_count+=1
                count_list.append(result)

print(group_count)
count_list.sort() # 오름 차순 정렬 
for i in range(len(count_list)):
    print(count_list[i])
```

## Reference
    - https://www.acmicpc.net/problem/2667
