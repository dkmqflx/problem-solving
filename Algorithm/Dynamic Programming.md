- 다이나믹 프로그래밍은 하나의 문제를 단 한번만 풀도록 하는 알고리즘이다
- 즉, 다이나믹 프로그래밍은 다음과 같은 과정으로 문제를 해결한다
    1. 큰 문제를 작은 문제로 나눈다
    2. 작은 문제에서 구한 정답은 작은 문제를 포함하는 큰 문제에서도 사용한다
 

- 피보나치 수열의 점화식은 다음과 같다  T[n] = T[n-1] + T[n-2] (n>2) 


```python
def dp(n):
    if n == 1 :
        return 1
    if n == 2:
        return 1
    return dp(n-1) + dp(n-2)

dp(10)
```




    55



- 위와 같이 피보나치 수열을 구현한 후 10보다 더 큰 수, 예를 들어 50과 같은 수를 입력하게 되면 너무나 많은 연산이 걸려서 제대로 작동하지 않게 된다
- 왜냐하면 이미 해결한 문제를 다시 반복적으로 해결하기 때문에 비효율적으로 많은 연산을 하게 된다 
- 예를 들어 T[10]을 구하는 경우
- T[10] = T[9] + T[8]
- T[9] = T[8] + T[7]
- 이처럼 T[9]를 구하는 과정이 반복되게 된다
- N이라는 수의 피보나치 수열을 구하려고 할 때, 높이는 대략적으로 N이 된다
- 그리고 트리의 구조로 나타내 볼 때 높이가 하나씩 커질 때 마다 각 노드는 $2^n$개로 증가하므로 총 연산 횟수는 $2^n$이다 
- 따라서 총 시간 복잡도는 $ O(2^n)$이 된다

- 따라서 이러한 문제를 해결하기 위해 Momorization을 사용한다.
- 이미 계산한 결과를 뱅려에 저장해줌으로써 나중에 동일한 계산을 해야할 때 저장한 값을 다시 가져와서 사용하는 것이다 
- Momorization을 사용해서 구현한 피보나치 점화식은 다음과 같다 
- 이미 계산한 결과는 배열에 저장되기 때문에 한번 구한 값을 다시 구하지 않는다 
- 이 경우 높이가 N인 경우 높이 만큼만 연산을 해주면 되기 때문에 시간 복잡도는 O(n)이 된다
- 예를 들면, T[10]을 구하기 위해서 T[9], T[8] .. 을 구하는 과정에서 다시 한번 더 계산을 하지 않기 때문이다


```python
m = [0] * 100

def dp(n):
    if n == 1 :
        return 1
    if n == 2:
        return 1
    if m[n] != 0:
        return m[n]
    m[n] = dp(n-1) + dp(n-2) 
    return m[n] 

dp(10)
```




    55



## Reference
- https://blog.naver.com/ndb796/221233570962
